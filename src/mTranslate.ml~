open Names
open Term
open Declarations
open Environ
open Globnames
open Pp

type modality = {
    mod_in : Constr.t;
    mod_O : Constr.t;
    mod_to : Constr.t
  }

(* Check if the type c is inductive, and if it is, if it has exactly one constructor *)
let inductive_with_one_constr env c =
  match kind_of_term c with
  |Ind (ind,_) ->
      let _, oib = Inductive.lookup_mind_specif env ind in
      let nc = Array.length oib.mind_consnames in
      if nc = 1 then true else false
  |_ -> false

let inductive_with_one_constr gl c =
  let env = Proofview.Goal.env gl in
  let n = inductive_with_one_constr env c in
  Pp.msg_info (Pp.str ("Inductive has "^(string_of_bool n)^" constructors"));
  Proofview.tclUNIT()


let rec translate env c = match kind_of_term c with
| Rel n -> mkRel n
| Var id -> mkVar id
| Sort s -> assert false
| Cast (c, k, t) -> assert false
| Prod (na, t, u) -> mkProd (na, translate env t, translate env u)
| Lambda (na, t, u) -> mkLambda (na, translate env t, translate env u)
| LetIn (na, c, t, u) -> mkLetIn (na, translate env c, translate env t, translate env u)
| App (t, args) ->
   let targs = Array.map (translate env) args in
   mkApp (translate env t, targs)
| Const pc -> assert false
| Ind (ind,i) -> assert false
| Construct pc -> assert false
| Case (ci, c, r, p) -> assert false
| Fix f -> assert false
| CoFix f -> assert false
| Proj (p, c) -> assert false
| Meta _ -> assert false
| Evar _ -> assert false
